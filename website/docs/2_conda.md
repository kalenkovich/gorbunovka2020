# conda

git позволяет нам хранить версии всего нашего кода.
Казалось бы, что этого достаточно для того, чтобы вопроизвести результаты его выполнения.
На самом деле, к сожалению, этого мало.
Этот код кто-то еще должен выполнить - интерпретатор Питона, Matlab, R - не так важно, кто.
И разные версии этих программ с большой вероятностью выдадут разные результаты, даже если ни ваш код, ни ваши данные при этом не поменялись.
А это значит, что ваш коллега или другой исследователь, который хочет воспользоваться вашим исследованием, не сможет получить те же результаты, что получились у вас.
На самом деле все даже еще чуть хуже: даже с нужной версий Питона, Matlab или R, у них могут быть другие версии пакетов в Питоне или R или тулбоксов в Matlab - и все равно они получат другие результаты.

Отличия при этом могут быть незначительными - `p = 0.0027`, вместо `p = 0.0028`.
Такое отличие, понятное дело, не имеет принципиального значения.
Но может быть и отличие в разы, а, возможно, код просто не запустится.
Чтобы понять, что пошло не так - нужно аккуратно и подробно задокументировать (и заверсионировать в вашем git-репо, конечно) версии всего софта и всех библиотек/тулбоксов, которыми вы пользовались - мы будем это называть *программным окружением*.
Это - программа-минимум: что-то скорее всего пойдет не так, но у вас хотя бы будет возможность попытаться понять, что именно к этому привело.
В случае если вы пользуетесь Matlab, это одновременно программа-максимум: если конкретную версию открытого тулбокса еще можно скачать, то ставить новый Matlab для каждого проекта и ставить/удалять нужные платные тулбоксы является совсем безумием.
(Поэтому давайте не будем пользоваться Matlab по возможности.)

Программа-максимум - использовать софт, который одновременно отслеживает версии программ/пакетов и позволяет вам их устанавливать.
При таком варианте при репликации достаточно установить этот софт, натравить его на файл, в котором записаны все версии рабочего софта - и вы получите копию программного окружения.
Такие программы называются *системами управления пакетами*.
Мы будем учиться пользоваться системой под названием *conda*.
Она позволит нам для каждого проекта установить свою версию Питона, R, пакетов для питона и некоторого дополнительного софта (например, pandoc, ffmpeg и т.д.).

## Environment

Ключевой возможностью conda является создание под каждый проект своей отдельной песочницы со своим питоном, своим R, своими пакетами для питона и прочим всяким.
Эти песочницы называются окружением среды (*environment*, *энвайронмент*).
Когда вы находитесь в энвайронменте (в случае conda мы говорим, что *энвайронмент* активирован), то запускаться будет именно тот Питон, тот R, которые вы поставили руками в этот энвайронмент.
При этом ничего, что у вас было установлено до создания энвайронмента, затронуто не будет.

*Задание*

- Откройте терминал в корне репозитория.
- Создайте новый энвайронмент под названием `reproducible_ds`:

    - наберите в терминале	
	
	```bash
	conda create -n reproducible_ds python=3.7
	```
		
    - подождите пару минут (это основная, по моему опыту, проблема conda - она мееддллееннааяя)
	- conda выдаст список того, что она планирует установить и спросит вас, готовы ли вы на такое (Proceed ([y]/n)?). Отвечайте, что готовы - наберите `y` и нажмите `enter`.
	
- Посмотрите, где, по мнению терминала, находится Питон (`where python` на Windows, `which python` на MacOS). Если вариантов несколько, то нас будет интересовать первый.
- Активируйте наш свежесозданный энвайронмент

    ```bash
	conda activate reproducible_ds
	```
	
- Посмотрите, где теперь находится Питон, и сравните с тем, что было.

Что только что произошло? Начнем с команды, которой мы создали энвайронмент:

```bash
conda create -n reproducible_ds python=3.7
```

С точки зрения терминала, он запустил `conda` с параметрами `create -n reproducible_ds python=3.7`.
Логика обработки параметров - это вопрос к conda, а не к терминалу, так что пока забудем про них.
Терминал начнет искать программу `conda` везде, где он только может.
В первом же месте, где найдет - ту `conda` и запустит.

> Чтобы посмотреть, где он может ее найти, мы можем в терминале набрать `where conda` (Windows) или `which conda` (MacOS).
> Терминал найдет программу `where`/`which` и передаст ей параметр `conda`.
> Можете выполнить `where where` или `which which` ради любопытства.
> Во многих случаях программу можно найти в нескольких местах, тогда `where`/`which` выдаст несколько строк.
> Запущена при этом будет только первая найденная программа.

Вернемся к параметрам, которые терминал передаст conda:

```bash
create -n reproducible_ds python=3.7
```

Каждый из параметров, разделенных пробелами, что-то сообщает conda:

- `create` говорит conda, что мы сейчас будем создавать новый энвайронмент,
- `-n` предупреждает, что следующий за ним параметр - название энвайронмента,
- `reproducible_ds` - название энвайронмента,
- `python=3.7` - в этом энвайронменте нужно устиновать `python` версии `3.7`.

> В конце команды мы могли добавить произвольное количество пакетов через пробел, опционально с указанием версий.
> Для conda python просто еще один пакет.

После того, как мы выполнили эту комманду, conda подготовила все для создания нового энвайронмента, спросила нас, согласны ли мы на все (мы ответили "да"), после чего собственно создала энвайронмент.
Пока это никак еще не повлияло на нашу работу, просто у нас на диске где-то появилась здоровая папка `reproducible_ds`.
В этом мы смогли убедиться, посмотрев, где, с точки зрения терминала, находится питон.
Обратите внимание, что его расположение никакого отношения к нашему новому энвайронменту не имеет.
Чтобы мы могли начать работать в нем, его нужно активировать:

```bash
conda activate reproducible_ds
```

Обратите внимание, что после этого в терминале в начале строки появилось название энвайронмента в скобках - это подсказка со стороны `conda`, что энвайронмент активирован.
Чтобы не полагаться на подсказки, мы опять посмотрели, где терминал будет искать питон.
В этот раз расположение находится в папке `reproducible_ds`, чего мы собственно и добивались.

## `environment.yml`

Пока мы успели создать новый энвайронмент и даже его активировать.
Это все, конечно, прекрасно, но пока мы никак не приблизились к тому, чтобы этот энвайрномент можно было воссоздать кому-то другому.
Для этого существуют энвайронмент-файлы - списки всего, что мы устанавливали в энвайронмент вместе с их версиями.
Дефолтное название для такого файла в случае conda - `environment.yml`.
Мы же сейчас создадим энвайронмент-файл и сохраним его в файл `environment-full.yml`.
Почему `-full` - к этому вы вернемся чуть позже.

*Задание*

- Запустите в терминале

    ```bash
    conda env export > environment-full.yml
    ```

- Откройте создавшийся файл `environment-full.yml` в текстовом редакторе. У меня он выглядит вот так:

	```yml
	name: reproducible_ds
	channels:
	  - defaults
	dependencies:
	  - ca-certificates=2020.10.14=0
	  - certifi=2020.6.20=pyhd3eb1b0_3
	  - openssl=1.1.1h=he774522_0
	  - pip=20.2.4=py37_0
	  - python=3.7.9=h60c2a47_0
	  - setuptools=50.3.0=py37h9490d1a_1
	  - sqlite=3.33.0=h2a8f88b_0
	  - vc=14.1=h0510ff6_4
	  - vs2015_runtime=14.16.27012=hf0eaf9b_3
	  - wheel=0.35.1=py_0
	  - wincertstore=0.2=py37_0
	  - zlib=1.2.11=h62dcd97_4
	prefix: D:\software_windows\miniconda3\envs\reproducible_ds
	```
	
	Если у вас файл отличается от моего - это нормально.
	
- Удалите из него части про `channels` и про `prefix`. Вот результат в моем случае:

	```yml
	name: reproducible_ds
	dependencies:
	  - ca-certificates=2020.10.14=0
	  - certifi=2020.6.20=pyhd3eb1b0_3
	  - openssl=1.1.1h=he774522_0
	  - pip=20.2.4=py37_0
	  - python=3.7.9=h60c2a47_0
	  - setuptools=50.3.0=py37h9490d1a_1
	  - sqlite=3.33.0=h2a8f88b_0
	  - vc=14.1=h0510ff6_4
	  - vs2015_runtime=14.16.27012=hf0eaf9b_3
	  - wheel=0.35.1=py_0
	  - wincertstore=0.2=py37_0
	  - zlib=1.2.11=h62dcd97_4
	```
	
- git
	
	- убедитесь, что вы на ветке `master`,
	- создайте ветку `<ваши_инициалы>_conda`,
	- закоммитьте файл `environment-full.yml`.
	
Мы убрали часть про `prefix`, потому что она осмысленна только на вашем компьютере и только при установке `conda` в том же самом месте.
Часть про `channels` мы убрали, потому что я предпочитаю указывать каналы на уровне отдельных пакетов, а не всего энвайронмента.
Если слово "каналы" в контексте conda вам пока ничего не говорит - это нормально, можете пока это все проигнорировать.

Наш энвайронмент-файл полностью описывает все, что есть в нашем энвайронменте.
В идеале мы бы пытались восстановить энвайронмент прямо на основании этого файла.
К сожалению, такой вариант часто очень плохо работает по разным причинам (разные операционные системы, критические обновления в технических пакетах и т.д.).
Поэтому в качестве компромиса мы будем держать в нашем энвайронмент-файле только версии пакетов, либо которые мы сами устанавливали (пока это только `python`), либо про которые мы знаем, что их версии хранить важно (в нашем случае в качестве такого пакета мы возьмем `pip`).

Версии каких пакетов важно хранить?
Однозначного ответа, к сожалению, нет.
Правило, которым пользуюсь я - если я когда-либо устанавливал какой-то пакет сам по себе - надо сохранить его версию.
Что будет, если этого окажется недостаточно?
Ну, что ж, придется раскапывать `environment-full.yml` и пытаться восстановиться по нему.
Будем надеяться, что такого с вами не произойдет.

*Задание*

- Сделайте копию `environment-full.yml` и назовите ее `environment.yml`.
- Удалите строки со всеми пакетам, кроме `python` и `pip`.
- Удалите текст после версий (начиная со второго `=`).
  У меня получилось следующее:
  
    ```yml
	name: reproducible_ds
	dependencies:
	  - pip=20.2.4
	  - python=3.7.9
	```
  
- Закоммитьте `environment.yml`.

## Воссоздание энвайронмента

Все, что осталось сделать вам либо кому-то ещё, чтобы восстановить энвайронмент - запустить следующий код в терминале, запущенном в той же папке, в которой лежит `environment.yml`:

```bash
conda env update -n reproducible_ds -f environment.yml --prune
```

Давайте разберем эту команду по частям:

- `env` - мы будем работать с набором подпрограмм для работы с энвайронментами,
- `update` - команда, которая обновляет, но также может и создать новый энвайронмент,
- `-n reproducible_ds_recreated` - энвайронмент с таким названимем будет обновлен или создан, если его еще нет,
- `-f environment.yml` - обновлять нужно будет до состояния, в котором в энвайронменте будут все пакеты из этого файла с указанными в нем версиями,
- `--prune` - удалит пакеты, которые не нужны для пакетов в `environment.yml`, релевантно только при обновлении.

Вообще говоря, есть специальная команда `create`, которая создана именно для создания энвайронмента.
Я решил дать вам вариант с `update`, потому что эту команду можно использовать как при создании энвайронмента по энвайронмент-файлу, так и при обновлении энвайронмент-файла после того, как файл был изменен.
Таким образом, вам  нужно будет учить на одну команду меньше.

## Установка новых пакетов

Если вы погуглите, как установить новый пакет, используя conda, вы не найдете тот замороченный способ, который я сейчас вам покажу.
К сожалению, со стандартным простым способом слишком велика вероятность получить `environment.yml` (напоминаю, что мы его вручную обновляем), который не соответствует действительности.
Поэтому пойдем замороченным путем.

Устанавливать мы будем `ipython` - интерактивную консоль для питона.
Если вы не знаете, что это такое - ничего страшного.
Последовательность действий не меняется, если нужно установить какой-то другой пакет.

*Задание*

- Добавьте в список `dependencies` в `environment.yml` следующую строчку:

	```yml
	  - ipython
	```
	
- Запустите команду для обновления энвайронмента (это та же самая команда, которая используется для воссоздания энвайронмента.
В отличие от `conda create` она ничего спрашивать, к сожалению, не будет.
- Посмотрите в список установленных пакетов и найдите там `ipython`.
- Перенесите версию `ipython` в `environment.yml` (ваша версия может отличаться от моей)

	```yml
	  - ipython=7.18.1
	```

- Обновите `environment-full.yml`.
Обновление делается так же, как создание.
- В SourceTree выделите по очереди `environment.yml` и `environment-full.yml` и посмотрите в панели справа, что поменялось.
- Закоммитьте оба файла с сообщением вроде `install ipython`.

Общий алгоритм при установке нового пакета `x` выглядит следующим образом:

- Добавьте новый пакет `x` с версией, если вы ее знаете, или без нее в список `dependencies` в `environment.yml`.
- `conda env update -n <env-name> -f environment.yml --prune`
- Допишите в `environment.yml` версию нового пакета, если не сделали этого вначале.
- Добавьте в `environment.yml` пакеты (вместе с версиями), которые установились во время установки `x` и заслуживают того, чтобы хранить их версию (см. главу про `environment.yml`).
- `conda env export > environment-full.yml`
- Проверьте, что изменения в `environment.yml` и `environment-full.yml` соответствут вашим ожиданиям.
- Закоммитьте `environment.yml` и `environment-full.yml`.

## Каналы

Когда conda устанавливает пакеты, она их ищет в хранилище anaconda.
По-дефолту, она их ищет в так называем канале `defaults`.
Канал - это просто раздел хранилища.
Некоторые пакеты не удостаиваются чести оказаться в `defаults`, поэтому при их установке нужно указать, в каком канале их надо искать.
Сегодня мы будем использовать только один дополнительный канал `conda-forge`, в котором расположен psychopy и R.

Вот так выглядит формат указания пакета с опциональным каналом и версией:

```yml
  - [<channel-name>::]<package-name>[=<version>]
```

Например, если мы хотим поставить psychopy 3.2.4, мы пропишем в `dependencies`

```yml
  - conda-forge::psychopy=3.2.4
```

### R

Начнем с простого - установим R.

*Задание*

- Установите R версии 4.0.1 из канала conda-forge. Пакет с R называется `r-base`.
Версии никаких дополнительных пакетов сохранять не нужно.
Все дополнительные пакеты помогают устанавливать библиотеки R, используя conda, чего мы делать все равно не будем.
- Проверьте, что все установилось, как надо - что R был установлен именно в наш энвайронмент, а не куда-то еще:
    - Проверьте, что терминал ищет R в папке с энвайронментом.
    - Проверьте, что запущенный R - именно тот R, который мы только что установили:
		- `r` - запуск R,
		- `R.home('bin')` - уточняем у R, где лежит его исполняемый файл,
		- `quit()` - выходим из R,
		- `n` - при выходе R спросит, хотим ли мы сохранить рабочую среду (`Save workspace image? [y/n/c]:`), чего мы не хотим - поэтому `n`.

### PsychoPy

> Установка psychopy займет мало вашего времени, но много машинного, поэтому не оставляйте ее на последний момент.
	
С psychopy все чуть-чуть сложнее: conda-пакет psychopy зависит от нескольких пакетов, которых нет в хранилище anaconda.
К счастью, они есть в другом хранилище - [PyPI](https://pypi.org/), для которого есть своя система управления пакетами - pip.
Если вы посмотрите в `environment.yml`, то увидите, что в нашем энвайронменте pip уже стоит и мы даже закрепили его версию.
К *не*счастью, conda-пакет psychopy не знает, как сказать conda, что ему нужно установить несколько pip-зависимостей.
Поэтому нам придется проставить их руками в `environment.yml`.
Вот, как это делается в общем случае:

```yml
name: <environment-name>
dependencies:
  - pip=<pip-version> # эта строка говрит conda, что нужно установить pip
  - <some-conda-package-1>
  ...
  - <some-conda-package-N>
  - pip:  # эта строка говрит conda, что следующие пакеты нужно установить, используя pip
    - <some-PyPI-package-1>
    ...
    - <some-PyPI-package-K>
```
*Задание*

- Откройте [инструкцию](https://www.psychopy.org/download.html#anaconda-and-miniconda) по установке psychopy с помощью conda.
- Откройте энвайронмент-файл `psychopy-env.yml`.
- Скопируйте из него то, что касается установки пакетов с помощью pip в `environment.yml`.
- Добавьте psychopy 3.2.4 из канала conda-forge в `environment.yml`. 
- Обновите энвайронмент, используя `environment.yml`.
- Обновите `environment-full.yml`.
- Закрепите версии следующих пакетов:
    - scipy
	- numpy
    - pandas
    - matplotlib
    - xarray
- Закрепите версии пакетов, установленных с помощью pip.
- Проверьте установку - запустите PsychoPy Builder:

	```bash
	python -m psychopy.app.psychopyApp -b
	```

- Если все прошло хорошо, то закоммитьте изменения в `environment.yml` и `environment-full.yml`

## Удаление

### Пакета

- Удалите пакет из `environment.yml`.
- Удалите из `environment.yml` все зависимости пакета, которые вы добавили вручную.
- Переустановите весь энвайронмент с помощью.

	```bash
	conda env create -f environment.yml --force	
	```
	
- Обновите `environment-full.yml` и закоммитьте все.
	
К сожалению, хоть мы и пишем во время обновления в конце `--prune`, что должно приводить к удалению лишних пакетов, понятие "лишних" на данный момент очень странное и зависит от истории установки пакетов.
Поэтому приходится создавать энвайронмент заново с нуля.
Следить за этой засадой можно вот в [этой](https://github.com/conda/conda/issues/7279) issue.

*Задание*

- Найдите способ найти все пакеты, которые мы закрепили в энвайронмент-файле вручную, когда устанавливали psychopy.
- Удалите psychopy.

### Энвайронмента

- Выйдите из энвайронмента, если вы в нём:

	```bash
	conda deactivate
	```
- Удалите энвайронмент:

	```bash
	conda remove -n <environment-name> --all
	```
	
*Задание*

Не трогайте ничего, нам еще понадобится наш энвайронмент :)
