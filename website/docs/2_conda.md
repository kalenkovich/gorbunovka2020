# conda

git позволяет нам хранить версии всего нашего кода.
Казалось бы, что этого достаточно для того, чтобы вопроизвести результаты его выполнения.
На самом деле, к сожалению, этого мало.
Этот код кто-то еще должен выполнить - интерпретатор Питона, Matlab, R - не так важно, кто.
И разные версии этих программ с большой вероятностью выдадут разные результаты, даже если ни ваш код, ни ваши данные при этом не поменялись.
А это значит, что ваш коллега или другой исследователь, который хочет воспользоваться вашим исследованием, не сможет получить те же результаты, что получились у вас.
На самом деле все даже еще чуть хуже: даже с нужной версий Питона, Matlab или R, у них могут быть другие версии пакетов в Питоне или R или тулбоксов в Matlab - и все равно они получат другие результаты.

Отличия при этом могут быть незначительными - `p = 0.0027`, вместо `p = 0.0028`.
Такое отличие, понятное дело, не имеет принципиального значения.
Но может быть и отличие в разы, а, возможно, код просто не запустится.
Чтобы понять, что пошло не так - нужно аккуратно и подробно задокументировать (и заверсионировать в вашем git-репо, конечно) версии всего софта и всех библиотек/тулбоксов, которыми вы пользовались - мы будем это называть *программным окружением*.
Это - программа-минимум: что-то скорее всего пойдет не так, но у вас хотя бы будет возможность попытаться понять, что именно к этому привело.
В случае если вы пользуетесь Matlab, это одновременно программа-максимум: если конкретную версию открытого тулбокса еще можно скачать, то ставить новый Matlab для каждого проекта и ставить/удалять нужные платные тулбоксы является совсем безумием.
(Поэтому давайте не будем пользоваться Matlab по возможности.)

Программа-максимум - использовать софт, который одновременно отслеживает версии программ/пакетов и позволяет вам их устанавливать.
При таком варианте при репликации достаточно установить этот софт, натравить его на файл, в котором записаны все версии рабочего софта - и вы получите копию программного окружения.
Такие программы называются *системами управления пакетами*.
Мы будем учиться пользоваться системой под названием *conda*.
Она позволит нам для каждого проекта установить свою версию Питона, R, пакетов для питона и некоторого дополнительного софта (например, pandoc, ffmpeg и т.д.).

## Environment

Ключевой возможностью conda является создание под каждый проект своей отдельной песочницы со своим питоном, своим R, своими пакетами для питона и прочим всяким.
Эти песочницы называются окружением среды (*environment*, *энвайронмент*).
Когда вы находитесь в энвайронменте (в случае conda мы говорим, что *энвайронмент* активирован), то запускаться будет именно тот Питон, тот R, которые вы поставили руками в этот энвайронмент.
При этом ничего, что у вас было установлено до создания энвайронмента, затронуто не будет.

*Задание*

- Откройте терминал в корне репозитория.
- Создайте новый энвайронмент под названием `reproducible_ds`:

    - наберите в терминале	
	
	```bash
	conda create -n reproducible_ds python=3.7
	```
		
    - подождите пару минут (это основная, по моему опыту, проблема conda - она мееддллееннааяя)
	- conda выдаст список того, что она планирует установить и спросит вас, готовы ли вы на такое (Proceed ([y]/n)?). Отвечайте, что готовы - наберите `y` и нажмите `enter`.
	
- Посмотрите, где, по мнению терминала, находится Питон (`where python` на Windows, `which python` на MacOS). Если вариантов несколько, то нас будет интересовать первый.
- Активируйте наш свежесозданный энвайронмент

    ```bash
	conda activate reproducible_ds
	```
	
- Посмотрите, где теперь находится Питон, и сравните с тем, что было.

Что только что произошло? Начнем с команды, которой мы создали энвайронмент:

```bash
conda create -n reproducible_ds python=3.7
```

С точки зрения терминала, он запустил `conda` с параметрами `create -n reproducible_ds python=3.7`.
Логика обработки параметров - это вопрос к conda, а не к терминалу, так что пока забудем про них.
Терминал начнет искать программу `conda` везде, где он только может.
В первом же месте, где найдет - ту `conda` и запустит.

> Чтобы посмотреть, где он может ее найти, мы можем в терминале набрать `where conda` (Windows) или `which conda` (MacOS).
> Терминал найдет программу `where`/`which` и передаст ей параметр `conda`.
> Можете выполнить `where where` или `which which` ради любопытства.
> Во многих случаях программу можно найти в нескольких местах, тогда `where`/`which` выдаст несколько строк.
> Запущена при этом будет только первая найденная программа.

Вернемся к параметрам, которые терминал передаст conda:

```bash
create -n reproducible_ds python=3.7
```

Каждый из параметров, разделенных пробелами, что-то сообщает conda:

- `create` говорит conda, что мы сейчас будем создавать новый энвайронмент,
- `-n` предупреждает, что следующий за ним параметр - название энвайронмента,
- `reproducible_ds` - название энвайронмента,
- `python=3.7` - в этом энвайронменте нужно устиновать `python` версии `3.7`.

> В конце команды мы могли добавить произвольное количество пакетов через пробел, опционально с указанием версий.
> Для conda python просто еще один пакет.

После того, как мы выполнили эту комманду, conda подготовила все для создания нового энвайронмента, спросила нас, согласны ли мы на все (мы ответили "да"), после чего собственно создала энвайронмент.
Пока это никак еще не повлияло на нашу работу, просто у нас на диске где-то появилась здоровая папка `reproducible_ds`.
В этом мы смогли убедиться, посмотрев, где, с точки зрения терминала, находится питон.
Обратите внимание, что его расположение никакого отношения к нашему новому энвайронменту не имеет.
Чтобы мы могли начать работать в нем, его нужно активировать:

```bash
conda activate reproducible_ds
```

Обратите внимание, что после этого в терминале в начале строки появилось название энвайронмента в скобках - это подсказка со стороны `conda`, что энвайронмент активирован.
Чтобы не полагаться на подсказки, мы опять посмотрели, где терминал будет искать питон.
В этот раз расположение находится в папке `reproducible_ds`, чего мы собственно и добивались.

## `environment.yml`

Пока мы успели создать новый энвайронмент и даже его активировать.
Это все, конечно, прекрасно, но пока мы никак не приблизились к тому, чтобы этот энвайрномент можно было воссоздать кому-то другому.
Для этого существуют энвайронмент-файлы - списки всего, что мы устанавливали в энвайронмент вместе с их версиями.
Дефолтное название для такого файла в случае conda - `environment.yml`.
Мы же сейчас создадим энвайронмент-файл и сохраним его в файл `environment-full.yml`.
Почему `-full` - к этому вы вернемся чуть позже.

*Задание*

- Запустите в терминале

    ```bash
    conda env export > environment-full.yml
    ```

- Откройте создавшийся файл `environment-full.yml` в текстовом редакторе. У меня он выглядит вот так:

	```yml
	name: reproducible_ds
	channels:
	  - defaults
	dependencies:
	  - ca-certificates=2020.10.14=0
	  - certifi=2020.6.20=pyhd3eb1b0_3
	  - openssl=1.1.1h=he774522_0
	  - pip=20.2.4=py37_0
	  - python=3.7.9=h60c2a47_0
	  - setuptools=50.3.0=py37h9490d1a_1
	  - sqlite=3.33.0=h2a8f88b_0
	  - vc=14.1=h0510ff6_4
	  - vs2015_runtime=14.16.27012=hf0eaf9b_3
	  - wheel=0.35.1=py_0
	  - wincertstore=0.2=py37_0
	  - zlib=1.2.11=h62dcd97_4
	prefix: D:\software_windows\miniconda3\envs\reproducible_ds
	```
	
	Если у вас файл отличается от моего - это нормально.
	
- Удалите из него части про `channels` и про `prefix`. Вот результат в моем случае:

	```yml
	name: reproducible_ds
	dependencies:
	  - ca-certificates=2020.10.14=0
	  - certifi=2020.6.20=pyhd3eb1b0_3
	  - openssl=1.1.1h=he774522_0
	  - pip=20.2.4=py37_0
	  - python=3.7.9=h60c2a47_0
	  - setuptools=50.3.0=py37h9490d1a_1
	  - sqlite=3.33.0=h2a8f88b_0
	  - vc=14.1=h0510ff6_4
	  - vs2015_runtime=14.16.27012=hf0eaf9b_3
	  - wheel=0.35.1=py_0
	  - wincertstore=0.2=py37_0
	  - zlib=1.2.11=h62dcd97_4
	```
	
- git
	
	- убедитесь, что вы на ветке `master`,
	- создайте ветку `<ваши_инициалы>_conda`,
	- закоммитьте файл `environment-full.yml`.
	
Мы убрали часть про `prefix`, потому что она осмысленна только на вашем компьютере и только при установке `conda` в том же самом месте.
Часть про `channels` мы убрали, потому что я предпочитаю указывать каналы на уровне отдельных пакетов, а не всего энвайронмента.
Если слово "каналы" в контексте conda вам пока ничего не говорит - это нормально, можете пока это все проигнорировать.

Наш энвайронмент-файл полностью описывает все, что есть в нашем энвайронменте.
В идеале мы бы пытались восстановить энвайронмент прямо на основании этого файла.
К сожалению, такой вариант часто очень плохо работает по разным причинам (разные операционные системы, критические обновления в технических пакетах и т.д.).
Поэтому в качестве компромиса мы будем держать в нашем энвайронмент-файле только версии пакетов, либо которые мы сами устанавливали (пока это только `python`), либо про которые мы знаем, что их версии хранить важно (в нашем случае в качестве такого пакета мы возьмем `pip`).

Версии каких пакетов важно хранить?
Однозначного ответа, к сожалению, нет.
Правило, которым пользуюсь я - если я когда-либо устанавливал какой-то пакет сам по себе - надо сохранить его версию.
Что будет, если этого окажется недостаточно?
Ну, что ж, придется раскапывать `environment-full.yml` и пытаться восстановиться по нему.
Будем надеяться, что такого с вами не произойдет.

*Задание*

- Сделайте копию `environment-full.yml` и назовите ее `environment.yml`.
- Удалите строки со всеми пакетам, кроме `python` и `pip`.
- Удалите текст после версий (начиная со второго `=`).
  У меня получилось следующее:
  
    ```yml
	name: reproducible_ds
	dependencies:
	  - pip=20.2.4
	  - python=3.7.9
	```
  
- Закоммитьте `environment.yml`.

## Воссоздание энвайронмента

Все, что осталось сделать вам либо кому-то ещё, чтобы восстановить энвайронмент - запустить следующий код в терминале, запущенном в той же папке, в которой лежит `environment.yml`:

```bash
conda env update -n reproducible_ds -f environment.yml --prune
```

Давайте разберем эту команду по частям:

- `env` - мы будем работать с набором подпрограмм для работы с энвайронментами,
- `update` - команда, которая обновляет, но также может и создать новый энвайронмент,
- `-n reproducible_ds_recreated` - энвайронмент с таким названимем будет обновлен или создан, если его еще нет,
- `-f environment.yml` - обновлять нужно будет до состояния, в котором в энвайронменте будут все пакеты из этого файла с указанными в нем версиями,
- `--prune` - удалит пакеты, которые не нужны для пакетов в `environment.yml`, релевантно только при обновлении.

Вообще говоря, есть специальная команда `create`, которая создана именно для создания энвайронмента.
Я решил дать вам вариант с `update`, потому что эту команду можно использовать как при создании энвайронмента по энвайронмент-файлу, так и при обновлении энвайронмент-файла после того, как файл был изменен.
Таким образом, вам  нужно будет учить на одну команду меньше.
