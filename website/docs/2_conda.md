# conda

git позволяет нам хранить версии всего нашего кода.
Казалось бы, что этого достаточно для того, чтобы вопроизвести результаты его выполнения.
На самом деле, к сожалению, этого мало.
Этот код кто-то еще должен выполнить - интерпретатор Питона, Matlab, R - не так важно, кто.
И разные версии этих программ с большой вероятностью выдадут разные результаты, даже если ни ваш код, ни ваши данные при этом не поменялись.
А это значит, что ваш коллега или другой исследователь, который хочет воспользоваться вашим исследованием, не сможет получить те же результаты, что получились у вас.
На самом деле все даже еще чуть хуже: даже с нужной версий Питона, Matlab или R, у них могут быть другие версии пакетов в Питоне или R или тулбоксов в Matlab - и все равно они получат другие результаты.

Отличия при этом могут быть незначительными - `p = 0.0027`, вместо `p = 0.0028`.
Такое отличие, понятное дело, не имеет принципиального значения.
Но может быть и отличие в разы, а, возможно, код просто не запустится.
Чтобы понять, что пошло не так - нужно аккуратно и подробно задокументировать (и заверсионировать в вашем git-репо, конечно) версии всего софта и всех библиотек/тулбоксов, которыми вы пользовались - мы будем это называть *программным окружением*.
Это - программа-минимум: что-то скорее всего пойдет не так, но у вас хотя бы будет возможность попытаться понять, что именно к этому привело.
В случае если вы пользуетесь Matlab, это одновременно программа-максимум: если конкретную версию открытого тулбокса еще можно скачать, то ставить новый Matlab для каждого проекта и ставить/удалять нужные платные тулбоксы является совсем безумием.
(Поэтому давайте не будем пользоваться Matlab по возможности.)

Программа-максимум - использовать софт, который одновременно отслеживает версии программ/пакетов и позволяет вам их устанавливать.
При таком варианте при репликации достаточно установить этот софт, натравить его на файл, в котором записаны все версии рабочего софта - и вы получите копию программного окружения.
Такие программы называются *системами управления пакетами*.
Мы будем учиться пользоваться системой под названием *conda*.
Она позволит нам для каждого проекта установить свою версию Питона, R, пакетов для питона и некоторого дополнительного софта (например, pandoc, ffmpeg и т.д.).

# Environment

Ключевой возможностью conda является создание под каждый проект своей отдельной песочницы со своим питоном, своим R, своими пакетами для питона и прочим всяким.
Эти песочницы называются окружением среды (*environment*, *энвайронмент*).
Когда вы находитесь в энвайронменте (в случае conda мы говорим, что *энвайронмент* активирован), то запускаться будет именно тот Питон, тот R, которые вы поставили руками в этот энвайронмент.
При этом ничего, что у вас было установлено до создания энвайронмента, затронуто не будет.

*Задание*

- Откройте терминал в корне репозитория.
- Создайте новый энвайронмент под названием `reproducible_ds`:

    - наберите в терминале	
	
	```bash
	conda create -n reproducible_ds python=3.7
	```
		
    - подождите пару минут (это основная, по моему опыту, проблема conda - она мееддллееннааяя)
	- conda выдаст список того, что она планирует установить и спросит вас, готовы ли вы на такое (Proceed ([y]/n)?). Отвечайте, что готовы - наберите `y` и нажмите `enter`.
	
- Посмотрите, где, по мнению терминала, находится Питон (`where python` на Windows, `which python` на MacOS). Если вариантов несколько, то нас будет интересовать первый.
- Активируйте наш свежесозданный энвайронмент

    ```bash
	conda activate reproducible_ds
	```
	
- Посмотрите, где теперь находится Питон, и сравните с тем, что было.

Что только что произошло? Начнем с команды, которой мы создали энвайронмент:

```bash
conda create -n reproducible_ds python=3.7
```

С точки зрения терминала, он запустил `conda` с параметрами `create -n reproducible_ds python=3.7`.
Логика обработки параметров - это вопрос к conda, а не к терминалу, так что пока забудем про них.
Терминал начнет искать программу `conda` везде, где он только может.
В первом же месте, где найдет - ту `conda` и запустит.

> Чтобы посмотреть, где он может ее найти, мы можем в терминале набрать `where conda` (Windows) или `which conda` (MacOS).
> Терминал найдет программу `where`/`which` и передаст ей параметр `conda`.
> Можете выполнить `where where` или `which which` ради любопытства.
> Во многих случаях программу можно найти в нескольких местах, тогда `where`/`which` выдаст несколько строк.
> Запущена при этом будет только первая найденная программа.

Вернемся к параметрам, которые терминал передаст conda:

```bash
create -n reproducible_ds python=3.7
```

Каждый из параметров, разделенных пробелами, что-то сообщает conda:

- `create` говорит conda, что мы сейчас будем создавать новый энвайронмент,
- `-n` предупреждает, что следующий за ним параметр - название энвайронмента,
- `reproducible_ds` - название энвайронмента,
- `python=3.7` - в этом энвайронменте нужно устиновать `python` версии `3.7`.

> В конце команды мы могли добавить произвольное количество пакетов через пробел, опционально с указанием версий.
> Для conda python просто еще один пакет.

После того, как мы выполнили эту комманду, conda подготовила все для создания нового энвайронмента, спросила нас, согласны ли мы на все (мы ответили "да"), после чего собственно создала энвайронмент.
Пока это никак еще не повлияло на нашу работу, просто у нас на диске где-то появилась здоровая папка `reproducible_ds`.
В этом мы смогли убедиться, посмотрев, где, с точки зрения терминала, находится питон.
Обратите внимание, что его расположение никакого отношения к нашему новому энвайронменту не имеет.
Чтобы мы могли начать работать в нем, его нужно активировать:

```bash
conda activate reproducible_ds
```

Обратите внимание, что после этого в терминале в начале строки появилось название энвайронмента в скобках - это подсказка со стороны `conda`, что энвайронмент активирован.
Чтобы не полагаться на подсказки, мы опять посмотрели, где терминал будет искать питон.
В этот раз расположение находится в папке `reproducible_ds`, чего мы собственно и добивались.
